# Updated Workflow File

name: Build with Maven, Unit Tests, Code Coverage, and Static Analysis

on:
  push:

env:
  IMAGE_NAME: ghcr.io/nus-iss-projects/bithealth-service/bithealth-service

jobs:
  build:
    name: Build, Unit Tests, and Code Coverage
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      repository-projects: write

    steps:
      - name: Checkout Source
        uses: actions/checkout@v3

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven

      - name: Build with Maven and Run Tests
        run: mvn -B package --file pom.xml

      - name: Upload JaCoCo Report
        uses: actions/upload-artifact@v4.6.1 # Using a specific version is good practice
        with:
          name: jacoco-report
          path: target/site/jacoco/

  sonar:
    name: Static Analysis with SonarCloud (SAST)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Source (Full History)
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: 17
          distribution: 'zulu' # Note: Using 'zulu' here, while 'temurin' elsewhere. Consistent distribution is often preferred unless there's a specific reason.

      - name: Cache SonarCloud Packages
        uses: actions/cache@v3
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar

      - name: Cache Maven Dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Run SonarCloud Analysis
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: mvn -B verify org.sonarsource.scanner.maven:sonar-maven-plugin:sonar -Dsonar.projectKey=NUS-ISS-Projects_BitHealth-service

  dast:
    name: Dynamic Application Security Testing (DAST) with OWASP ZAP
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push'

    # Define the PostgreSQL service container
    services:
      postgres:
        image: postgres:15 # Or your desired PostgreSQL version
        env:
          # Set credentials for the temporary CI database
          POSTGRES_USER: ci_user
          POSTGRES_PASSWORD: ci_password # Use a secret if needed for the DB password
          POSTGRES_DB: ci_db
        ports:
          # Map port 5432 in the container to port 5432 on the runner host
          - 5432:5432
        # Options to wait for the database service to be healthy
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout Source
        uses: actions/checkout@v3

      - name: Permit ZAP to write reports
        run: sudo chmod -R a+rwX $GITHUB_WORKSPACE

      - name: Start BitHealth for DAST and Wait for Health Check
        id: start_app
        # Set environment variables needed by the application
        # These will be picked up by application.properties placeholders
        env:
          SPRING_PROFILES_ACTIVE: ci # Keep activating CI profile if it has other non-DB settings
          # Database credentials pointing to the service container on localhost
          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/ci_db
          SPRING_DATASOURCE_USERNAME: ci_user
          SPRING_DATASOURCE_PASSWORD: ci_password # Match the service env password
          # Firebase credentials from GitHub Secrets
          FIREBASE_SA_B64: ${{ secrets.FIREBASE_SA_B64_CI }}
        run: |
          echo "Waiting for PostgreSQL service..."
          # Optional: Add an explicit wait/check for the DB port if needed, though 'services' handles health checks
          sleep 15 # Give the service a bit more time to initialize fully (adjust if needed)

          echo "Starting application with DB service..."
          # Run the application using the CI profile (it will use ENV vars for DB)
          nohup mvn spring-boot:run \
            -Dspring-boot.run.profiles=ci \
            -Dspring-boot.run.arguments="--server.address=0.0.0.0" \
            > app.log 2>&1 &
          APP_PID=$!
          echo "Application started with PID $APP_PID. Waiting up to 120s for HTTP 200 on /actuator/healthâ€¦"
          # ... (Rest of the robust wait loop from previous updates remains the same) ...
          # ... (The loop checks /actuator/health and prints app.log on failure) ...

      - name: Run OWASP ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.8.0
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          target: 'http://localhost:8080' # Target the app running on the runner host
          docker_name: 'ghcr.io/zaproxy/zaproxy:stable'

      - name: Upload DAST HTML Report
        uses: actions/upload-artifact@v4
        if: always() # Upload report even if ZAP fails
        with:
          name: zap-report
          path: report_html.html

  setup-build-deploy:
    name: Setup, Build, and Store Artifact
    runs-on: ubuntu-latest
    # It might make sense for this job to depend on 'build' and maybe 'sonar'
    # needs: [build, sonar] # Uncomment if you want this to run only after build and sonar succeed
    steps:
      - name: Checkout Source
        uses: actions/checkout@v3

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: 17
          cache: maven # Added Maven cache here too for consistency

      # Consider if 'mvn package' from 'build' job is sufficient, or if 'install' is truly needed
      - name: Maven Clean Install
        run: mvn clean install --batch-mode --errors --fail-at-end

      - name: Upload Artifact
        uses: actions/upload-artifact@v4.6.1
        with:
          name: bithealth-app.jar
          # The default path for the jar created by 'mvn install' (or 'package')
          path: target/*.jar
          # Optional: prevent errors if no JAR found (e.g., build failure)
          # if-no-files-found: error # Default is 'warn'

  build-docker-image:
    name: Dockerize and Push to GitHub Container Registry
    # This job depends on the artifact created in setup-build-deploy
    needs: setup-build-deploy
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout Source
        # Technically might not be needed if Dockerfile only needs the JAR,
        # but usually kept for context or if Dockerfile references other source files.
        uses: actions/checkout@v3

      - name: Set build date as image tag
        run: echo "IMAGE_TAG=$(date +'%Y%m%d%H%M%S')" >> $GITHUB_ENV

      - name: Retrieve Saved Artifact
        uses: actions/download-artifact@v4.1.9 # Using a specific version
        with:
          name: bithealth-app.jar
          path: target/ # Download the artifact into the target directory

      - name: List Files in Artifact Directory
        run: ls -l target/ # Verify the JAR file is present

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2 # Consider using latest stable v3.x.x

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2 # Consider using latest stable v3.x.x
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Push Multi-Architecture Docker Image
        uses: docker/build-push-action@v4 # Consider using latest stable v5.x.x
        with:
          context: . # Build context is the current directory
          # file: ./Dockerfile # Explicitly specify Dockerfile if not in root
          platforms: linux/amd64,linux/arm64 # Specify target platforms
          push: true # Push the image to the registry
          tags: | # Define image tags
            ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
            ${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha # Enable GitHub Actions cache for Docker layer caching
          cache-to: type=gha,mode=max